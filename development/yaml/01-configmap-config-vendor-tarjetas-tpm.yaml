kind: ConfigMap
apiVersion: v1
metadata:
  name: config-vendor-tarjetas-tpm
  namespace: tarjetas-tpm
data:
  TimestampBehavior.php: >
    <?php
    declare(strict_types=1);

    /**
    * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)
    * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    *
    * Licensed under The MIT License
    * For full copyright and license information, please see the LICENSE.txt
    * Redistributions of files must retain the above copyright notice.
    *
    * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    * @link          https://cakephp.org CakePHP(tm) Project
    * @since         3.0.0
    * @license       https://opensource.org/licenses/mit-license.php MIT License
    */
    namespace Cake\ORM\Behavior;

    use Cake\Database\Type\DateTimeType;
    use Cake\Database\TypeFactory;
    use Cake\Datasource\EntityInterface;
    use Cake\Event\EventInterface;
    use Cake\I18n\FrozenTime;
    use Cake\ORM\Behavior;
    use DateTimeInterface;
    use RuntimeException;
    use UnexpectedValueException;

    /**
    * Class TimestampBehavior
    */
    class TimestampBehavior extends Behavior
    {
        /**
        * Default config
        *
        * These are merged with user-provided config when the behavior is used.
        *
        * events - an event-name keyed array of which fields to update, and when, for a given event
        * possible values for when a field will be updated are "always", "new" or "existing", to set
        * the field value always, only when a new record or only when an existing record.
        *
        * refreshTimestamp - if true (the default) the timestamp used will be the current time when
        * the code is executed, to set to an explicit date time value - set refreshTimetamp to false
        * and call setTimestamp() on the behavior class before use.
        *
        * @var array<string, mixed>
        */
        protected $_defaultConfig = [
            'implementedFinders' => [],
            'implementedMethods' => [
                'timestamp' => 'timestamp',
                'touch' => 'touch',
            ],
            'events' => [
                'Model.beforeSave' => [
                    'CREATED' => 'new',
                    'MODIFIED' => 'always',
                ],
            ],
            'refreshTimestamp' => true,
        ];

        /**
        * Current timestamp
        *
        * @var \Cake\I18n\FrozenTime|null
        */
        protected $_ts;

        /**
        * Initialize hook
        *
        * If events are specified - do *not* merge them with existing events,
        * overwrite the events to listen on
        *
        * @param array<string, mixed> $config The config for this behavior.
        * @return void
        */
        public function initialize(array $config): void
        {
            if (isset($config['events'])) {
                $this->setConfig('events', $config['events'], false);
            }
        }

        /**
        * There is only one event handler, it can be configured to be called for any event
        *
        * @param \Cake\Event\EventInterface $event Event instance.
        * @param \Cake\Datasource\EntityInterface $entity Entity instance.
        * @throws \UnexpectedValueException if a field's when value is misdefined
        * @return true Returns true irrespective of the behavior logic, the save will not be prevented.
        * @throws \UnexpectedValueException When the value for an event is not 'always', 'new' or 'existing'
        */
        public function handleEvent(EventInterface $event, EntityInterface $entity): bool
        {
            $eventName = $event->getName();
            $events = $this->_config['events'];

            $new = $entity->isNew() !== false;
            $refresh = $this->_config['refreshTimestamp'];

            foreach ($events[$eventName] as $field => $when) {
                if (!in_array($when, ['always', 'new', 'existing'], true)) {
                    throw new UnexpectedValueException(sprintf(
                        'When should be one of "always", "new" or "existing". The passed value "%s" is invalid',
                        $when
                    ));
                }
                if (
                    $when === 'always' ||
                    (
                        $when === 'new' &&
                        $new
                    ) ||
                    (
                        $when === 'existing' &&
                        !$new
                    )
                ) {
                    $this->_updateField($entity, $field, $refresh);
                }
            }

            return true;
        }

        /**
        * implementedEvents
        *
        * The implemented events of this behavior depend on configuration
        *
        * @return array<string, mixed>
        */
        public function implementedEvents(): array
        {
            return array_fill_keys(array_keys($this->_config['events']), 'handleEvent');
        }

        /**
        * Get or set the timestamp to be used
        *
        * Set the timestamp to the given DateTime object, or if not passed a new DateTime object
        * If an explicit date time is passed, the config option `refreshTimestamp` is
        * automatically set to false.
        *
        * @param \DateTimeInterface|null $ts Timestamp
        * @param bool $refreshTimestamp If true timestamp is refreshed.
        * @return \Cake\I18n\FrozenTime
        */
        public function timestamp(?DateTimeInterface $ts = null, bool $refreshTimestamp = false): DateTimeInterface
        {
            if ($ts) {
                if ($this->_config['refreshTimestamp']) {
                    $this->_config['refreshTimestamp'] = false;
                }
                $this->_ts = new FrozenTime($ts);
            } elseif ($this->_ts === null || $refreshTimestamp) {
                $this->_ts = new FrozenTime();
            }

            return $this->_ts;
        }

        /**
        * Touch an entity
        *
        * Bumps timestamp fields for an entity. For any fields configured to be updated
        * "always" or "existing", update the timestamp value. This method will overwrite
        * any pre-existing value.
        *
        * @param \Cake\Datasource\EntityInterface $entity Entity instance.
        * @param string $eventName Event name.
        * @return bool true if a field is updated, false if no action performed
        */
        public function touch(EntityInterface $entity, string $eventName = 'Model.beforeSave'): bool
        {
            $events = $this->_config['events'];
            if (empty($events[$eventName])) {
                return false;
            }

            $return = false;
            $refresh = $this->_config['refreshTimestamp'];

            foreach ($events[$eventName] as $field => $when) {
                if (in_array($when, ['always', 'existing'], true)) {
                    $return = true;
                    $entity->setDirty($field, false);
                    $this->_updateField($entity, $field, $refresh);
                }
            }

            return $return;
        }

        /**
        * Update a field, if it hasn't been updated already
        *
        * @param \Cake\Datasource\EntityInterface $entity Entity instance.
        * @param string $field Field name
        * @param bool $refreshTimestamp Whether to refresh timestamp.
        * @return void
        */
        protected function _updateField(EntityInterface $entity, string $field, bool $refreshTimestamp): void
        {
            if ($entity->isDirty($field)) {
                return;
            }

            $ts = $this->timestamp(null, $refreshTimestamp);

            $columnType = $this->table()->getSchema()->getColumnType($field);
            if (!$columnType) {
                return;
            }

            /** @var \Cake\Database\Type\DateTimeType $type */
            $type = TypeFactory::build($columnType);

            if (!$type instanceof DateTimeType) {
                throw new RuntimeException('TimestampBehavior only supports columns of type DateTimeType.');
            }

            $class = $type->getDateTimeClassName();

            $entity->set($field, new $class($ts));
        }
    }
  OCI8Statement.php: >
    <?php
    declare(strict_types=1);

    /**
    * Copyright 2015 - 2020, Cake Development Corporation (http://cakedc.com)
    *
    * Licensed under The MIT License
    * Redistributions of files must retain the above copyright notice.
    *
    * @copyright Copyright 2015 - 2020, Cake Development Corporation (http://cakedc.com)
    * @license MIT License (http://www.opensource.org/licenses/mit-license.php)
    */
    namespace CakeDC\OracleDriver\Database\OCI8;

    use PDO;

    /**
    * The OCI8 implementation of the Statement interface.
    */
    class OCI8Statement extends \PDOStatement implements \IteratorAggregate
    {
        /**
        * @var bool
        */

        protected $_returnLobs = true;

        /**
        * @var resource
        */
        protected $_dbh;

        /**
        * @var resource
        */
        protected $_sth;

        /**
        * @var \CakeDC\OracleDriver\Database\OCI8\OCI8Connection
        */
        protected $_conn;

        /**
        * @var string
        */
        protected static $_PARAM = ':param';

        /**
        * @var array
        */
        protected static $fetchModeMap = [
            PDO::FETCH_BOTH => OCI_BOTH,
            PDO::FETCH_ASSOC => OCI_ASSOC,
            PDO::FETCH_NUM => OCI_NUM,
            PDO::FETCH_COLUMN => OCI_NUM,
        ];

        /**
        * Column number for PDO::FETCH_COLUMN fetch mode
        *
        * @var int
        */
        protected $_fetchColumnNumber = 0;

        /**
        * @var int
        */
        protected $_defaultFetchMode = PDO::ATTR_DEFAULT_FETCH_MODE;

        /**
        * @var array
        */
        protected $_paramMap = [];

        /**
        * @var array
        */
        protected $_values = [];

        protected $_fetchMode = PDO::ATTR_DEFAULT_FETCH_MODE;

        protected $_fetchClassName = '\stdClass';

        protected $_fetchIntoObject = null;

        protected $_fetchArguments = [];

        protected $_results = [];

        /**
        * Creates a new OCI8Statement that uses the given connection handle and SQL statement.
        *
        * @param resource $dbh The connection handle.
        * @param string|resource $statement The SQL statement.
        * @param \CakeDC\OracleDriver\Database\OCI8\OCI8Connection $conn OCI connection.
        */
        public function __construct($dbh, $statement, OCI8Connection $conn)
        {
            if (is_resource($statement)) {
                $this->_sth = $statement;
                $paramMap = [];
            } else {
                [$statement, $paramMap] = self::convertPositionalToNamedPlaceholders($statement);
                $this->_sth = oci_parse($dbh, $statement);
            }
            $this->_dbh = $dbh;
            $this->_paramMap = $paramMap;
            $this->_conn = $conn;
        }

        /**
        * Converts positional (?) into named placeholders (:param<num>).
        *
        * Oracle does not support positional parameters, hence this method converts all
        * positional parameters into artificially named parameters. Note that this conversion
        * is not perfect. All question marks (?) in the original statement are treated as
        * placeholders and converted to a named parameter.
        *
        * The algorithm uses a state machine with two possible states: InLiteral and NotInLiteral.
        * Question marks inside literal strings are therefore handled correctly by this method.
        * This comes at a cost, the whole sql statement has to be looped over.
        *
        * @param string $statement The SQL statement to convert.
        *
        * @return string
        */
        public static function convertPositionalToNamedPlaceholders($statement)
        {
            $count = 1;
            $inLiteral = false;
            $stmtLen = strlen($statement);
            $paramMap = [];
            for ($i = 0; $i < $stmtLen; $i++) {
                if ($statement[$i] === '?' && !$inLiteral) {
                    $paramMap[$count] = ":param$count";
                    $len = strlen($paramMap[$count]);
                    $statement = substr_replace($statement, ":param$count", $i, 1);
                    $i += $len - 1;
                    $stmtLen = strlen($statement);
                    ++$count;
                } elseif ($statement[$i] === "'" || $statement[$i] === '"') {
                    $inLiteral = !$inLiteral;
                }
            }

            return [$statement, $paramMap];
        }

        /**
        * {@inheritdoc}
        */
        public function bindValue($param, $value, $type = null)
        {
            $this->_values[$param] = $value;

            return $this->bindParam($param, $this->_values[$param], $type, null);
        }

        /**
        * {@inheritdoc}
        */
        public function bindParam($column, &$variable, $type = null, $length = null, $driverData = null)
        {
            $column = $this->_paramMap[$column] ?? $column;

            // @todo add additional type passing: as an option we could accept $type as array
            // where $type = ['ociType' => "REAL_OCI_TYPE", 'plsql_type' => 'VARRAY', 'php_type' => 'string']
            // this way we could choose correct type and correct binding function like oci_bind_array_by_name

            if ($type == \PDO::PARAM_STMT) {
                $variable = oci_new_cursor($this->_dbh);

                return oci_bind_by_name($this->_sth, $column, $variable, -1, OCI_B_CURSOR);
            } elseif ($type == \PDO::PARAM_LOB) {
                $lob = oci_new_descriptor($this->_dbh, OCI_D_LOB);
                $lob->writeTemporary($variable, OCI_TEMP_BLOB);

                return oci_bind_by_name($this->_sth, $column, $lob, -1, OCI_B_BLOB);
            } elseif ($length !== null) {
                return oci_bind_by_name($this->_sth, $column, $variable, $length);
            }

            return oci_bind_by_name($this->_sth, $column, $variable);
        }

        /**
        * {@inheritdoc}
        */
        public function closeCursor()
        {
            return true;
        }

        /**
        * {@inheritdoc}
        */
        public function __destruct()
        {
            if (is_resource($this->_sth)) {
                oci_free_statement($this->_sth);
            }
        }

        /**
        * {@inheritdoc}
        */
        public function columnCount()
        {
            return oci_num_fields($this->_sth);
        }

        /**
        * {@inheritdoc}
        */
        public function errorCode()
        {
            $error = oci_error($this->_sth);
            if ($error !== false) {
                $error = $error['code'];
            } else {
                return '00000';
            }

            return $error;
        }

        /**
        * {@inheritdoc}
        */
        public function errorInfo()
        {
            return oci_error($this->_sth);
        }

        /**
        * {@inheritdoc}
        */
        public function execute($params = null)
        {
            if ($params) {
                $hasZeroIndex = array_key_exists(0, $params);
                foreach ($params as $key => $val) {
                    if ($hasZeroIndex && is_numeric($key)) {
                        $this->bindValue($key + 1, $val);
                    } else {
                        $this->bindValue($key, $val);
                    }
                }
            }

            $ret = @oci_execute($this->_sth, $this->_conn->getExecuteMode());
            if (!$ret) {
                throw OCI8Exception::fromErrorInfo($this->errorInfo());
            }

            return $ret;
        }

        /**
        * {@inheritdoc}
        */
        public function getIterator()
        {
            $data = $this->fetchAll();

            return new \ArrayIterator($data);
        }

        /**
        * {@inheritdoc}
        */
        public function fetch($fetchMode = null, $orientation = null, $offset = null)
        {
            $toLowercase = ($this->getAttribute(PDO::ATTR_CASE) == PDO::CASE_LOWER);
            $nullToString = ($this->getAttribute(PDO::ATTR_ORACLE_NULLS) == PDO::NULL_TO_STRING);
            $nullEmptyString = ($this->getAttribute(PDO::ATTR_ORACLE_NULLS) == PDO::NULL_EMPTY_STRING);

            $fetchMode = $fetchMode ?: $this->_defaultFetchMode;

            switch ($fetchMode) {
                case PDO::FETCH_BOTH:
                    $rs = oci_fetch_array($this->_sth);
                    if ($rs === false) {
                        return false;
                    }
                    if ($toLowercase) {
                        $rs = array_change_key_case($rs);
                    } 
                    if ($this->_returnLobs && is_array($rs)) {
                        foreach ($rs as $field => $value) {
                            if (is_object($value)) {
                                $rs[$field] = $value->load();
                            }
                        }
                    }

                    return $rs;

                case PDO::FETCH_ASSOC:
                    $rs = oci_fetch_assoc($this->_sth);
                    if ($rs === false) {
                        return false;
                    }

                    $rs = $this->pseudoCamelCase($rs);

                    if ($toLowercase) {
                        $rs = array_change_key_case($rs);
                    }
                    if ($this->_returnLobs && is_array($rs)) {
                        foreach ($rs as $field => $value) {
                            if (is_object($value)) {
                                $rs[$field] = $value->load();
                            }
                        }
                    }

                    return $rs;

                case PDO::FETCH_NUM:
                    $rs = oci_fetch_row($this->_sth);
                    if ($rs === false) {
                        return false;
                    }
                    if ($this->_returnLobs && is_array($rs)) {
                        foreach ($rs as $field => $value) {
                            if (is_object($value)) {
                                $rs[$field] = $value->load();
                            }
                        }
                    }

                    return $rs;

                case PDO::FETCH_COLUMN:
                    $rs = oci_fetch_row($this->_sth);
                    $columnNumber = (int)$this->_fetchColumnNumber;
                    if (is_array($rs) && array_key_exists($columnNumber, $rs)) {
                        $value = $rs[$columnNumber];
                        if (is_object($value)) {
                            return $value->load();
                        } else {
                            return $value;
                        }
                    } else {
                        return false;
                    }
                    break;

                case PDO::FETCH_OBJ:
                case PDO::FETCH_INTO:
                case PDO::FETCH_CLASS:
                case PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE:
                    $rs = oci_fetch_assoc($this->_sth);
                    if ($rs === false) {
                        return false;
                    }
                    if ($toLowercase) {
                        $rs = array_change_key_case($rs);
                    }

                    if ($fetchMode === PDO::FETCH_INTO) {
                        if (is_object($this->_fetchIntoObject)) {
                            $object = $this->_fetchIntoObject;
                        } else {
                            return false;
                        }
                    } else {
                        if ($fetchMode === PDO::FETCH_OBJ) {
                            $className = '\stdClass';
                            $arguments = [];
                        } else {
                            $className = $this->_fetchClassName;
                            $arguments = $this->_fetchArguments;
                        }

                        if ($arguments) {
                            $reflectionClass = new \ReflectionClass($className);
                            $object = $reflectionClass->newInstanceArgs($arguments);
                        } else {
                            $object = new $className();
                        }
                    }

                    foreach ($rs as $field => $value) {
                        if (is_null($value) && $nullToString) {
                            $rs[$field] = '';
                        }

                        if (empty($rs[$field]) && $nullEmptyString) {
                            $rs[$field] = null;
                        }

                        $object->$field = $this->_returnLobs && is_object($value) ? $value->load() : $value;
                    }

                    return $object;
            }

            return false;
        }

        public function pseudoCamelCase($rs){
            $rsCamelCase = [];
            if (is_array($rs)) {
                foreach ($rs as $key => $value) {
                    if($key == 'COUNT' || $key == 'EXISTING'){
                        $key = strtolower($key);
                    }else{
                        $pos = (strpos($key,'_CREATED'))? 7:8;
                        if(strpos($key,'_CREATED') || strpos($key,'_MODIFIED')){
                            $key = strtoupper(substr($key,0,1)) . strtolower(substr($key,1,(strlen($key)-$pos-1))) . substr($key,(strlen($key)-$pos));
                        }else if(strpos($key,'CJOIN')){
                            $key = strtoupper(substr($key,0,1)) . strtolower(substr($key,1,strpos($key,'CJOIN')-1)) . str_replace("CJOIN",'CJoin',substr($key,strpos($key,'CJOIN')));
                        }else{
                            $key = strtoupper(substr($key,0,1)) . strtolower(substr($key,1));
                            if(strpos($key,'__')){
                                $key2 = strtoupper(substr($key,0,1)) . strtolower(substr($key,1,strpos($key,'__')-1)) . strtoupper(substr($key,strpos($key,'__')));
                                // echo('<br>' . $key2 . '<br>');
                                $rsCamelCase[$key2] = $value;
                            }
                        }
                    }
                    
                    
                    $rsCamelCase[$key] = $value;
                } 
                
                // echo('<br>');
                // print_r($rsCamelCase);
                // echo('<br>');
            }
            return $rsCamelCase;
        }

        /**
        * {@inheritdoc}
        */
        public function fetchAll($fetchMode = null, $className = null, $arguments = null)
        {
            $fetchArgument = $className;
            $this->setFetchMode($fetchMode, $fetchArgument, $arguments);

            $this->_results = [];
            while ($row = $this->fetch()) {
                if (is_resource(reset($row))) {
                    $stmt = new OCI8Statement($this->_dbh, reset($row), $this->_conn);
                    $stmt->execute();
                    $stmt->setFetchMode($fetchMode, $fetchArgument, $arguments);
                    while ($rs = $stmt->fetch()) {
                        $this->_results[] = $rs;
                    }
                } else {
                    $this->_results[] = $row;
                }
            }

            return $this->_results;
        }

        /**
        * {@inheritdoc}
        */
        public function fetchColumn($columnIndex = 0)
        {
            $row = oci_fetch_array($this->_sth, OCI_NUM | OCI_RETURN_NULLS | OCI_RETURN_LOBS);

            if ($row === false) {
                return false;
            }

            return $row[$columnIndex] ?? null;
        }

        /**
        * {@inheritdoc}
        */
        public function rowCount()
        {
            if (is_resource($this->_sth)) {
                return oci_num_rows($this->_sth);
            }

            return 0;
        }

        /**
        * Retrieve a statement attribute
        *
        * @param string $attribute Attribute id.
        * @return mixed The attribute value.
        */
        public function getAttribute($attribute)
        {
            return $this->_conn->getConfig((string)$attribute);
        }

        /**
        * Set the default fetch mode for this statement
        *
        * @param int|null $fetchMode The fetch mode must be one of the PDO::FETCH_* constants.
        * @param mixed|null $param Column number, class name or object.
        * @param array|null $arguments Constructor arguments.
        * @throws \CakeDC\OracleDriver\Database\OCI8\Oci8Exception
        * @return bool TRUE on success or FALSE on failure.
        */
        public function setFetchMode($fetchMode, $param = null, $arguments = [])
        {
            $this->_defaultFetchMode = $fetchMode;

            switch ($fetchMode) {
                case PDO::FETCH_ASSOC:
                case PDO::FETCH_NUM:
                case PDO::FETCH_BOTH:
                case PDO::FETCH_OBJ:
                    $this->_fetchMode = $fetchMode;
                    $this->_fetchColumnNumber = 0;
                    $this->_fetchClassName = '\stdClass';
                    $this->_fetchArguments = [];
                    $this->_fetchIntoObject = null;
                    break;
                case PDO::FETCH_CLASS:
                case PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE:
                    $this->_fetchMode = $fetchMode;
                    $this->_fetchColumnNumber = 0;
                    $this->_fetchClassName = '\stdClass';
                    if ($param) {
                        $this->_fetchClassName = $param;
                    }
                    $this->_fetchArguments = $arguments;
                    $this->_fetchIntoObject = null;
                    break;
                case PDO::FETCH_INTO:
                    if (!is_object($param)) {
                        throw new OCI8Exception(__('$param must be instance of an object'));
                    }
                    $this->_fetchMode = $fetchMode;
                    $this->_fetchColumnNumber = 0;
                    $this->_fetchClassName = '\stdClass';
                    $this->_fetchArguments = [];
                    $this->_fetchIntoObject = $param;
                    break;
                case PDO::FETCH_COLUMN:
                    $this->_fetchMode = $fetchMode;
                    $this->_fetchColumnNumber = (int)$param;
                    $this->_fetchClassName = '\stdClass';
                    $this->_fetchArguments = [];
                    $this->_fetchIntoObject = null;
                    break;
                default:
                    throw new OCI8Exception(__('Requested fetch mode is not supported by this implementation'));
            }

            return true;
        }
    }
  PasswordIdentifier.php: >
    <?php
    declare(strict_types=1);

    /**
    * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)
    * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    *
    * Licensed under The MIT License
    * For full copyright and license information, please see the LICENSE.txt
    * Redistributions of files must retain the above copyright notice.
    *
    * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    * @link          https://cakephp.org CakePHP(tm) Project
    * @since         1.0.0
    * @license       https://opensource.org/licenses/mit-license.php MIT License
    */
    namespace Authentication\Identifier;

    use Authentication\Identifier\Resolver\ResolverAwareTrait;
    use Authentication\Identifier\Resolver\ResolverInterface;
    use Authentication\PasswordHasher\PasswordHasherFactory;
    use Authentication\PasswordHasher\PasswordHasherInterface;
    use Authentication\PasswordHasher\PasswordHasherTrait;

    /**
    * Password Identifier
    *
    * Identifies authentication credentials with password
    *
    * ```
    *  new PasswordIdentifier([
    *      'fields' => [
    *          'username' => ['username', 'email'],
    *          'password' => 'password'
    *      ]
    *  ]);
    * ```
    *
    * When configuring PasswordIdentifier you can pass in config to which fields,
    * model and additional conditions are used.
    */
    class PasswordIdentifier extends AbstractIdentifier
    {
        use PasswordHasherTrait {
            getPasswordHasher as protected _getPasswordHasher;
        }
        use ResolverAwareTrait;

        /**
        * Default configuration.
        * - `fields` The fields to use to identify a user by:
        *   - `username`: one or many username fields.
        *   - `password`: password field.
        * - `resolver` The resolver implementation to use.
        * - `passwordHasher` Password hasher class. Can be a string specifying class name
        *    or an array containing `className` key, any other keys will be passed as
        *    config to the class. Defaults to 'Default'.
        *
        * @var array
        */
        protected $_defaultConfig = [
            'fields' => [
                self::CREDENTIAL_USERNAME => 'username',
                self::CREDENTIAL_PASSWORD => 'password',
            ],
            'resolver' => 'Authentication.Orm',
            'passwordHasher' => null,
        ];

        /**
        * Return password hasher object.
        *
        * @return \Authentication\PasswordHasher\PasswordHasherInterface Password hasher instance.
        */
        public function getPasswordHasher(): PasswordHasherInterface
        {
            if ($this->_passwordHasher === null) {
                $passwordHasher = $this->getConfig('passwordHasher');
                if ($passwordHasher !== null) {
                    $passwordHasher = PasswordHasherFactory::build($passwordHasher);
                } else {
                    $passwordHasher = $this->_getPasswordHasher();
                }
                $this->_passwordHasher = $passwordHasher;
            }

            return $this->_passwordHasher;
        }

        /**
        * @inheritDoc
        */
        public function identify(array $credentials)
        {
            if (!isset($credentials[self::CREDENTIAL_USERNAME])) {
                return null;
            }

            $identity = $this->_findIdentity($credentials[self::CREDENTIAL_USERNAME]);
            if (array_key_exists(self::CREDENTIAL_PASSWORD, $credentials)) {
                $password = $credentials[self::CREDENTIAL_PASSWORD];
                if (!$this->_checkPassword($identity, $password)) {
                    return null;
                }
            }

            return $identity;
        }

        /**
        * Find a user record using the username and password provided.
        * Input passwords will be hashed even when a user doesn't exist. This
        * helps mitigate timing attacks that are attempting to find valid usernames.
        *
        * @param array|\ArrayAccess|null $identity The identity or null.
        * @param string|null $password The password.
        * @return bool
        */
        protected function _checkPassword($identity, ?string $password): bool
        {
            $passwordField = $this->getConfig('fields.' . self::CREDENTIAL_PASSWORD);

            if ($identity === null) {
                $identity = [
                    $passwordField => '',
                ];
            }

            $hasher = $this->getPasswordHasher();
            $hashedPassword = $identity[strtoupper($passwordField)];
            if (
                $hashedPassword === null ||
                !$hasher->check((string)$password, $hashedPassword)
            ) {
                return false;
            }

            $this->_needsPasswordRehash = $hasher->needsRehash($hashedPassword);

            return true;
        }

        /**
        * Find a user record using the username/identifier provided.
        *
        * @param string $identifier The username/identifier.
        * @return \ArrayAccess|array|null
        */
        protected function _findIdentity(string $identifier)
        {
            $fields = $this->getConfig('fields.' . self::CREDENTIAL_USERNAME);
            $conditions = [];
            foreach ((array)$fields as $field) {
                $conditions[$field] = $identifier;
            }

            return $this->getResolver()->find($conditions, ResolverInterface::TYPE_OR);
        }
    }
  OracleSchema.php: >
    <?php
        declare(strict_types=1);

        /**
        * Copyright 2015 - 2020, Cake Development Corporation (http://cakedc.com)
        *
        * Licensed under The MIT License
        * Redistributions of files must retain the above copyright notice.
        *
        * @copyright Copyright 2015 - 2020, Cake Development Corporation (http://cakedc.com)
        * @license MIT License (http://www.opensource.org/licenses/mit-license.php)
        */
        namespace CakeDC\OracleDriver\Database\Schema;

        use Cake\Database\Schema\BaseSchema;
        use Cake\Database\Schema\TableSchema;
        use Cake\Utility\Hash;
        use CakeDC\OracleDriver\Database\Exception\UnallowedDataTypeException;

        /**
        * Schema management/reflection features for Oracle.
        */
        class OracleSchema extends BaseSchema
        {
            protected $_constraints = [];

            /**
            * Generate the SQL to list the methods.
            *
            * @param array $config The connection configuration to use for

            *    getting tables from.
            * @return array An array of (sql, params) to execute.
            */
            public function listMethodsSql($config)
            {
                if (empty($config['schema'])) {
                    $table = 'user_procedures';
                    $useOwner = false;
                    $params = [];
                } else {
                    $table = 'all_procedures';
                    $useOwner = true;
                    $params = [':ownerParam' => strtoupper($config['schema'])];
                    $ownerCondition = 'AND OWNER = :ownerParam';
                }
                $objectNameField = $this->_transformFieldCase("OBJECT_NAME");
                $procedureName = $this->_transformFieldCase("PROCEDURE_NAME");
                $objectCondition = '';
                if (!empty($config['objectName'])) {
                    $objectName = $config['objectName'];

                    $items = explode('.', $objectName);
                    $itemsCount = count($items);
                    if ($itemsCount === 3) {
                        [$schema, $package, $object] = explode('.', $objectName);
                    } elseif ($itemsCount === 2) {
                        [$package, $object] = explode('.', $objectName);
                    } else {
                        $schema = $package = null;
                        $object = $objectName;
                    }
                    $ownerCondition = '';
                    $params = [
                        ':objectParam' => $object,
                    ];
                    if (empty($schema) && empty($package)) {
                        $table = 'user_procedures';
                        $useOwner = false;
                        $objectCondition = " AND $objectNameField = :objectParam ";
                    } else {
                        $table = 'all_procedures';
                        $useOwner = true;
                        if (!empty($package) && !empty($schema)) {
                            $ownerCondition = " AND OWNER = :ownerParam AND $objectNameField = :packageParam ";
                            $params = [
                                ':objectParam' => $object,
                                ':packageParam' => $package,
                                ':ownerParam' => $schema,
                            ];
                            $objectCondition = " AND $procedureName = :objectParam ";
                        } elseif (!empty($package)) {
                            $ownerCondition = " AND (OWNER = :packageParam OR $objectNameField = :packageParam) ";
                            $params = [
                                ':objectParam' => $object,
                                ':packageParam' => $package,
                            ];
                            $objectCondition = " AND $procedureName = :objectParam ";
                        }
                    }
                }
                $procedureName = $this->_transformFieldCase("PROCEDURE_NAME");
                $sql = "SELECT $objectNameField as object, $procedureName as name, OBJECT_TYPE FROM $table
        WHERE 1=1 " . ($useOwner ? $ownerCondition : '') . $objectCondition . " ORDER BY object, name";

                return [
                    $sql,
                    $params,
                ];
            }

            /**
            * {@inheritDoc}
            */
            public function listTablesSql(array $config): array
            {
                if (empty($config['schema'])) {
                    $table = 'user_tables';
                    $useOwner = false;
                    $params = [];
                } else {
                    $table = 'all_tables';
                    $useOwner = true;
                    $params = [':ownerParam' => strtoupper($config['schema'])];
                }
                $tableName = $this->_transformFieldCase("TABLE_NAME");
                $sql = "SELECT $tableName as name FROM $table " . ($useOwner ? 'WHERE owner = :ownerParam' : '') . " ORDER BY name";

                return [
                    $sql,
                    $params,
                ];
            }

            /**
            * {@inheritDoc}
            */
            public function describeColumnSql(string $tableName, array $config): array
            {
                [$schema, $table] = $this->tableSplit($tableName, $config);
                if (empty($schema)) {
                    $columnsTable = 'user_tab_columns';
                    $commentsTable = 'user_col_comments';
                    $useOwner = false;
                    $params = [':tableParam' => $table];
                } else {
                    $columnsTable = 'all_tab_columns';
                    $commentsTable = 'all_col_comments';
                    $useOwner = true;
                    $params = [
                        ':tableParam' => $table,
                        ':ownerParam' => $schema,
                    ];
                }
                $sql = "SELECT
                            utc.table_name as \"table\",
                            utc.column_name AS name,
                            utc.data_type AS type,
                            utc.data_length AS char_length,
                            utc.data_precision,
                            utc.data_scale,
                            utc.nullable AS \"null\",
                            utc.data_default AS \"default\",
                            ucc.comments AS \"comment\",
                            utc.column_id AS ordinal_position
                        FROM $columnsTable utc
                        JOIN $commentsTable ucc ON (
                            utc.table_name = ucc.table_name
                            AND utc.column_name = ucc.column_name
                        " . ($useOwner ? 'AND utc.OWNER = ucc.OWNER' : '') . "
                        )
                        WHERE UPPER(utc.table_name) = :tableParam
                        " . ($useOwner ? 'AND utc.OWNER = :ownerParam' : '') . "
                        ORDER BY utc.column_id";

                return [
                    $sql,
                    $params,
                ];
            }

            /**
            * {@inheritDoc}
            */
            public function convertColumnDescription(TableSchema $schema, array $row): void
            {
                $row = array_change_key_case($row);
                switch ($row['type']) {
                    case 'DATE':
                        $field = [
                            'type' => TableSchema::TYPE_DATETIME,
                            'length' => null,
                        ];
                        break;
                    case 'TIMESTAMP':
                    case 'TIMESTAMP(6)':
                    case 'TIMESTAMP(9)':
                        $field = [
                            'type' => TableSchema::TYPE_TIMESTAMP,
                            'length' => null,
                        ];
                        break;
                    case 'NUMBER':
                    case 'INTEGER':
                    case 'PLS_INTEGER':
                    case 'BINARY_INTEGER':
                        if ($row['data_precision'] == 1) {
                            $field = [
                                'type' => TableSchema::TYPE_BOOLEAN,
                                'length' => null,
                            ];
                        } elseif ($row['data_scale'] > 0) {
                            $field = [
                                'type' => TableSchema::TYPE_DECIMAL,
                                'length' => $row['data_precision'],
                                'precision' => $row['data_scale'],
                            ];
                        } else {
                            $field = [
                                'type' => TableSchema::TYPE_INTEGER,
                                'length' => $row['data_precision'],
                            ];
                        }
                        break;
                    case 'FLOAT':
                    case 'BINARY_FLOAT':
                    case 'BINARY_DOUBLE':
                        $field = [
                            'type' => TableSchema::TYPE_FLOAT,
                            'length' => $row['data_precision'],
                        ];
                        break;
                    case 'NCHAR':
                    case 'NVARCHAR2':
                    case 'CHAR':
                    case 'VARCHAR2':
                    case 'LONG':
                    case 'ROWID':
                    case 'UROWID':
                        $length = $row['char_length'];
                        if ($length == 36) {
                            $field = [
                                'type' => TableSchema::TYPE_UUID,
                                'length' => null,
                            ];
                        } else {
                            $field = [
                                'type' => TableSchema::TYPE_STRING,
                                'length' => $length,
                            ];
                        }
                        break;
                    case 'NCLOB':
                    case 'CLOB':
                        $field = [
                            'type' => TableSchema::TYPE_TEXT,
                            'length' => $row['char_length'],
                        ];
                        break;
                    case 'RAW':
                    case 'LONG RAW':
                    case 'BLOB':
                        $field = [
                            'type' => TableSchema::TYPE_BINARY,
                            'length' => $row['char_length'],
                        ];
                        break;
                    default:
                }
                $field += [
                    'null' => $row['null'] === 'Y',
                    'default' => $row['default'],
                    'comment' => $row['comment'],
                ];
                $schema->addColumn($this->_transformValueCase($row['name']), $field);
            }

            /**
            * Generate the SQL to describe a parameter.
            *
            * @param string $objectName The table name to get information on.
            * @param array $config The connection configuration.
            * @return array An array of (sql, params) to execute.
            */
            public function describeParametersSql($objectName, $config)
            {
                $items = explode('.', $objectName);
                $itemsCount = count($items);
                if ($itemsCount === 3) {
                    [$schema, $package, $object] = explode('.', $objectName);
                } elseif ($itemsCount === 2) {
                    [$package, $object] = explode('.', $objectName);
                } else {
                    $schema = $package = null;
                    $object = $objectName;
                }
                $ownerCondition = '';
                $params = [
                    ':objectParam' => $object,
                ];
                if (empty($schema) && empty($package)) {
                    $argumentsTable = 'user_arguments';
                    $useOwner = false;
                } else {
                    $argumentsTable = 'all_arguments';
                    $useOwner = true;
                    if (!empty($package) && !empty($schema)) {
                        $ownerCondition = 'AND args.OWNER = :ownerParam AND args.PACKAGE_NAME = :packageParam ';
                        $params = [
                            ':objectParam' => $object,
                            ':packageParam' => $package,
                            ':ownerParam' => $schema,
                        ];
                    } elseif (!empty($package)) {
                        $ownerCondition = 'AND (args.OWNER = :packageParam OR args.PACKAGE_NAME = :packageParam) ';
                        $params = [
                            ':objectParam' => $object,
                            ':packageParam' => $package,
                        ];
                    }
                }
                $sql = "SELECT
                            args.object_name as \"object\",
                            args.package_name AS package,
                            args.argument_name AS name,
                            args.data_type AS type,
                            args.pls_type AS pls_type,
                            args.in_out AS direction,
                            args.data_length,
                            args.data_precision,
                            args.data_scale,
                            args.position AS ordinal_position
                        FROM $argumentsTable args
                        WHERE UPPER(args.object_name) = :objectParam
                        " . ($useOwner ? $ownerCondition : '') . "
                        ORDER BY args.position";

                return [
                    $sql,
                    $params,
                ];
            }

            /**
            * Convert parameter description results into abstract schema fields.
            *
            * @param \CakeDC\OracleDriver\Database\Schema\MethodSchema $method The method object to append parameters to.
            * @param array $row The row data from `describeParametersSql`.
            * @return void
            */
            public function convertParametersDescription(MethodSchema $method, $row)
            {
                $row = array_change_key_case($row);
                switch ($row['type']) {
                    case 'DATE':
                        $field = [
                            'type' => TableSchema::TYPE_DATETIME,
                            'length' => null,
                        ];
                        break;
                    case 'TIMESTAMP':
                    case 'TIMESTAMP(6)':
                    case 'TIMESTAMP(9)':
                        $field = [
                            'type' => TableSchema::TYPE_TIMESTAMP,
                            'length' => null,
                        ];
                        break;
                    case 'NUMBER':
                    case 'INTEGER':
                    case 'PLS_INTEGER':
                    case 'BINARY_INTEGER':
                        if ($row['data_precision'] == 1) {
                            $field = [
                                'type' => TableSchema::TYPE_BOOLEAN,
                                'length' => null,
                            ];
                        } elseif ($row['data_scale'] > 0) {
                            $field = [
                                'type' => TableSchema::TYPE_DECIMAL,
                                'length' => $row['data_precision'],
                                'precision' => $row['data_scale'],
                            ];
                        } else {
                            $field = [
                                'type' => TableSchema::TYPE_INTEGER,
                                'length' => $row['data_precision'],
                            ];
                        }
                        break;
                    case 'FLOAT':
                    case 'BINARY_FLOAT':
                    case 'BINARY_DOUBLE':
                        $field = [
                            'type' => TableSchema::TYPE_FLOAT,
                            'length' => $row['data_precision'],
                        ];
                        break;
                    case 'NCHAR':
                    case 'NVARCHAR2':
                    case 'CHAR':
                    case 'VARCHAR2':
                    case 'LONG':
                    case 'ROWID':
                    case 'UROWID':
                        $length = $row['data_length'];
                        if ($length == 36) {
                            $field = [
                                'type' => TableSchema::TYPE_UUID,
                                'length' => null,
                            ];
                        } else {
                            $field = [
                                'type' => TableSchema::TYPE_STRING,
                                'length' => $length,
                            ];
                        }
                        break;
                    case 'NCLOB':
                    case 'CLOB':
                        $field = [
                            'type' => TableSchema::TYPE_TEXT,
                            'length' => $row['data_length'],
                        ];
                        break;
                    case 'RAW':
                    case 'LONG RAW':
                    case 'BLOB':
                        $field = [
                            'type' => TableSchema::TYPE_BINARY,
                            'length' => $row['data_length'],
                        ];
                        break;
                    case 'REF CURSOR':
                        $field = [
                            'type' => 'cursor',
                        ];
                        break;
                    default:
                }
                $out = strpos($row['direction'], 'OUT') !== false;
                $name = $row['name'];
                $function = $out && $name === null;
                $field += [
                    'in' => strpos($row['direction'], 'IN') !== false,
                    'out' => $out,
                    'function' => $function,
                ];
                if ($function) {
                    $name = ':result';
                }
                $method->addParameter($name, $field);
            }

            /**
            * {@inheritDoc}
            */
            public function describeIndexSql(string $tableName, array $config): array
            {
                $this->_constraints[$tableName] = [];
                [$schema, $table] = $this->tableSplit($tableName, $config);
                if (empty($schema)) {
                    $constraintsTable = 'user_constraints';
                    $indexesTable = 'user_indexes';
                    $indexColumnsTable = 'user_ind_columns';
                    $useOwner = false;
                } else {
                    $constraintsTable = 'all_constraints';
                    $indexesTable = 'all_indexes';
                    $indexColumnsTable = 'all_ind_columns';
                    $useOwner = true;
                }

                $sql = "SELECT
                    ic.index_name AS name,
                    (
                        SELECT i.index_type
                        FROM   $indexesTable i
                        WHERE  i.index_name = ic.index_name" . ($useOwner ? ' AND ic.table_owner = i.table_owner' : '') . "
                    ) AS type,
                    decode(
                        (
                            SELECT i.uniqueness
                            FROM   $indexesTable i
                            WHERE  i.index_name = ic.index_name" . ($useOwner ? ' AND ic.table_owner = i.table_owner' : '') . "
                        ),
                        'NONUNIQUE', 0,
                        'UNIQUE', 1
                    ) AS is_unique,
                    ic.column_name AS column_name,
                    ic.column_position AS column_pos,
                    COALESCE(
                        (
                            SELECT c.constraint_type 
                            FROM user_constraints c 
                            WHERE c.constraint_name = ic.index_name
                        ), 'N/A'
                    ) AS is_primary
                    FROM $indexColumnsTable ic
                    WHERE upper(ic.table_name) = :tableParam" . ($useOwner ? ' AND ic.table_owner = :ownerParam' : '') . "
                    ORDER BY ic.column_position ASC";

                $params = [
                    ':tableParam' => $table,
                ];
                if ($useOwner) {
                    $params[':ownerParam'] = $schema;
                }

                return [$sql, $params];
            }

            /**
            * {@inheritDoc}
            */
            public function convertIndexDescription(TableSchema $schema, array $row): void
            {
                $tableIndex = array_change_key_case($row);
                $type = null;
                $columns = $length = [];

                $keyName = $this->_transformValueCase($tableIndex['name']);
                $name = $this->_transformValueCase($tableIndex['column_name']);
                if (strtolower($tableIndex['is_primary']) === 'p') {
                    $keyName = $type = TableSchema::CONSTRAINT_PRIMARY;
                } elseif ($tableIndex['is_unique'] !== []) {
                    $type = TableSchema::CONSTRAINT_UNIQUE;
                } else {
                    $type = TableSchema::INDEX_INDEX;
                }

                $columns[] = $this->_transformValueCase($name);

                $isIndex = $type === TableSchema::INDEX_INDEX;
                $existing = $isIndex ? $schema->getIndex($keyName) : $schema->getConstraint($keyName);

                if (!empty($existing)) {
                    $columns = array_merge($existing['columns'], $columns);
                }
                if ($isIndex) {
                    $schema->addIndex($keyName, [
                        'type' => $type,
                        'columns' => $columns,
                    ]);
                } else {
                    $schema->addConstraint($keyName, [
                        'type' => $type,
                        'columns' => $columns,
                    ]);
                }
            }

            /**
            * Convert a column list into a clean array.
            *
            * @param string $columns comma separated column list.
            * @return array
            */
            protected function _convertColumnList($columns)
            {
                $columns = explode(', ', $columns);
                foreach ($columns as &$column) {
                    $column = trim($column, '"');
                }

                return $columns;
            }

            /**
            * {@inheritDoc}
            */
            public function describeForeignKeySql(string $tableName, array $config): array
            {
                [$schema, $table] = $this->tableSplit($tableName, $config);

                if (empty($schema)) {
                    $sql = "SELECT
                                cc.column_name,
                                cc.constraint_name,
                                r.owner as referenced_owner,
                                r.table_name as referenced_table_name,
                                r.column_name as referenced_column_name,
                                c.delete_rule
                            FROM user_cons_columns cc
                            JOIN user_constraints c ON c.constraint_name = cc.constraint_name
                            JOIN user_cons_columns r ON r.constraint_name = c.r_constraint_name
                            WHERE c.constraint_type = 'R'
                            AND upper(cc.table_name) = :tableParam
                            ";

                    return [
                        $sql,
                        [':tableParam' => $table],
                    ];
                }
                $sql = "
                    SELECT
                        cc.column_name,
                        cc.constraint_name,
                        r.owner as referenced_owner,
                        r.table_name as referenced_table_name,
                        r.column_name as referenced_column_name,
                        c.delete_rule
                    FROM all_cons_columns cc
                    JOIN all_constraints c ON (c.constraint_name = cc.constraint_name AND c.owner = cc.owner)
                    JOIN all_cons_columns r ON (r.constraint_name = c.r_constraint_name AND r.owner = c.r_owner)
                    WHERE c.constraint_type = 'R'
                    AND cc.owner = :ownerParam
                    AND upper(cc.table_name) = :tableParam";

                return [
                    $sql,
                    [
                        ':tableParam' => $table,
                        ':ownerParam' => $schema,
                    ],
                ];
            }

            /**
            * {@inheritDoc}
            */
            public function convertForeignKeyDescription(TableSchema $schema, array $row): void
            {
                $row = array_change_key_case($row);
                $data = [
                    'type' => TableSchema::CONSTRAINT_FOREIGN,
                    'columns' => strtoupper($row['column_name']),
                    'references' => [
                        $row['referenced_owner'] . '.' . $row['referenced_table_name'],
                        strtoupper($row['referenced_column_name']),
                    ],
                    'update' => TableSchema::ACTION_SET_NULL,
                    'delete' => $this->_convertOnClause($row['delete_rule']),
                ];
                $schema->addConstraint($row['constraint_name'], $data);
            }

            /**
            * {@inheritDoc}
            */
            protected function _convertOnClause(string $clause): string
            {
                if ($clause === 'RESTRICT') {
                    return TableSchema::ACTION_RESTRICT;
                }
                if ($clause === 'NO ACTION') {
                    return TableSchema::ACTION_NO_ACTION;
                }
                if ($clause === 'CASCADE') {
                    return TableSchema::ACTION_CASCADE;
                }

                return TableSchema::ACTION_SET_NULL;
            }

            /**
            * {@inheritDoc}
            */
            public function columnSql(TableSchema $schema, string $name): string
            {
                $data = $schema->getColumn($name);
                $out = $this->_driver->quoteIfAutoQuote($name);
                $typeMap = [
                    TableSchema::TYPE_INTEGER => ' NUMBER',
                    TableSchema::TYPE_SMALLINTEGER => ' NUMBER',
                    TableSchema::TYPE_TINYINTEGER => ' NUMBER',
                    TableSchema::TYPE_BIGINTEGER => ' NUMBER',
                    TableSchema::TYPE_BOOLEAN => ' NUMBER(1)',
                    TableSchema::TYPE_BINARY => ' BLOB',
                    TableSchema::TYPE_FLOAT => ' FLOAT',
                    TableSchema::TYPE_DECIMAL => ' NUMBER',
                    TableSchema::TYPE_TEXT => ' CLOB',
                    TableSchema::TYPE_DATE => ' TIMESTAMP',
                    TableSchema::TYPE_TIME => ' TIMESTAMP',
                    TableSchema::TYPE_DATETIME => ' TIMESTAMP',
                    TableSchema::TYPE_TIMESTAMP => ' TIMESTAMP',
                    TableSchema::TYPE_UUID => ' VARCHAR2(36)',
                ];

                if (!isset($typeMap[$data['type']]) && $data['type'] != TableSchema::TYPE_STRING) {
                    throw new UnallowedDataTypeException(['type' => $data['type']]);
                }

                if (isset($typeMap[$data['type']])) {
                    $out .= $typeMap[$data['type']];
                }

                if ($data['type'] === TableSchema::TYPE_STRING) {
                    $isFixed = !empty($data['fixed']);
                    $type = ' VARCHAR2';
                    if ($isFixed) {
                        $type = ' CHAR';
                    }
                    $out .= $type;
                    if (!isset($data['length'])) {
                        $data['length'] = 255;
                    }
                    $out .= '(' . (int)$data['length'] . ')';
                }

                if ($data['type'] === TableSchema::TYPE_INTEGER && isset($data['length'])) {
                    $out .= '(' . (int)$data['length'] . ')';
                }

                if (($data['type'] === TableSchema::TYPE_FLOAT || $data['type'] === TableSchema::TYPE_DECIMAL) && (isset($data['length']) || isset($data['precision']))) {
                    $out .= '(' . (int)$data['length'] . ',' . (int)$data['precision'] . ')';
                }

                if ($this->_driver->useAutoincrement()) {
                    if (
                        $this->__isInteger($data['type']) && (array)$schema->getPrimaryKey() ===
                        [$name]
                    ) {
                        $out .= ' GENERATED BY DEFAULT AS IDENTITY (START WITH 1)';
                        //$out .= ' GENERATED ALWAYS AS IDENTITY START WITH 1 INCREMENT BY 1';
                    }
                }

                if (isset($data['null']) && $data['null'] === true) {
                    $out .= ' DEFAULT NULL';
                    unset($data['default']);
                }
                if (isset($data['default']) && $data['type'] !== TableSchema::TYPE_TIMESTAMP) {
                    $defaultValue = $data['default'];
                    if ($data['type'] === TableSchema::TYPE_BOOLEAN) {
                        $defaultValue = (int)$defaultValue;
                    }
                    $out .= ' DEFAULT ' . $this->_driver->schemaValue($defaultValue);
                }

                if (isset($data['null']) && $data['null'] === false) {
                    $out .= ' NOT NULL';
                }

                return $out;
            }

            /**
            * {@inheritDoc}
            */
            public function addConstraintSql(TableSchema $schema): array
            {
                $sqlPattern = 'ALTER TABLE %s ADD %s;';
                $sql = [];

                foreach ($schema->constraints() as $name) {
                    $constraint = $schema->getConstraint($name);
                    if ($constraint['type'] === TableSchema::CONSTRAINT_FOREIGN) {
                        $tableName = $this->_driver->quoteIfAutoQuote($schema->name());
                        $sql[] = sprintf($sqlPattern, $tableName, $this->constraintSql($schema, $name));
                    }
                }

                return $sql;
            }

            /**
            * {@inheritDoc}
            */
            public function dropConstraintSql(TableSchema $schema): array
            {
                $sqlPattern = 'ALTER TABLE %s DROP CONSTRAINT %s;';
                $sql = [];

                foreach ($schema->constraints() as $name) {
                    $constraint = $schema->getConstraint($name);
                    if ($constraint['type'] === TableSchema::CONSTRAINT_FOREIGN) {
                        $tableName = $this->_driver->quoteIfAutoQuote($schema->name());
                        $constraintName = $this->_driver->quoteIfAutoQuote($name);
                        $sql[] = sprintf($sqlPattern, $tableName, $constraintName);
                    }
                }

                return $sql;
            }

            /**
            * {@inheritDoc}
            */
            public function indexSql(TableSchema $schema, string $name): string
            {
                $data = $schema->getIndex($name);
                $columns = array_map([
                    $this->_driver,
                    'quoteIfAutoQuote',
                ], $data['columns']);

                return sprintf(
                    'CREATE INDEX %s ON %s (%s)',
                    $this->_driver->quoteIfAutoQuote($name),
                    $this->_driver->quoteIfAutoQuote($schema->name()),
                    implode(', ', $columns)
                );
            }

            /**
            * {@inheritDoc}
            */
            public function constraintSql(TableSchema $schema, string $name): string
            {
                $data = $schema->getConstraint($name);
                $out = 'CONSTRAINT ' . $this->_driver->quoteIfAutoQuote($name);
                if ($data['type'] === TableSchema::CONSTRAINT_PRIMARY) {
                    $out = 'PRIMARY KEY';
                }
                if ($data['type'] === TableSchema::CONSTRAINT_UNIQUE) {
                    $out .= ' UNIQUE';
                }

                return $this->_keySql($out, $data);
            }

            /**
            * Helper method for generating key SQL snippets.
            *
            * @param string $prefix The key prefix
            * @param array $data Key data.
            * @return string
            */
            protected function _keySql($prefix, $data)
            {
                $columns = array_map([
                    $this->_driver,
                    'quoteIfAutoQuote',
                ], $data['columns']);
                if ($data['type'] === TableSchema::CONSTRAINT_FOREIGN) {
                    return $prefix . sprintf(
                        ' FOREIGN KEY (%s) REFERENCES %s (%s) ON DELETE %s DEFERRABLE INITIALLY IMMEDIATE',
                        implode(', ', $columns),
                        $this->_driver->quoteIfAutoQuote($data['references'][0]),
                        $this->_convertConstraintColumns($data['references'][1]),
                        $this->_foreignOnClause($data['update']),
                        $this->_foreignOnClause($data['delete'])
                    );
                }

                return $prefix . ' (' . implode(', ', $columns) . ')';
            }

            /**
            * {@inheritDoc}
            */
            public function createTableSql(
                TableSchema $schema,
                array $columns,
                array $constraints,
                array $indexes
            ): array {
                $content = array_merge($columns, $constraints);
                $content = implode(",\n", array_filter($content));
                $tableName = $this->_driver->quoteIfAutoQuote($schema->name());
                $temporary = $schema->isTemporary() ? ' TEMPORARY ' : ' ';
                $out = [];
                $out[] = sprintf("CREATE%sTABLE %s (\n%s\n)", $temporary, $tableName, $content);
                foreach ($indexes as $index) {
                    $out[] = $index;
                }
                foreach ($schema->columns() as $column) {
                    $columnData = $schema->getColumn($column);
                    if (isset($columnData['comment'])) {
                        $out[] = sprintf(
                            'COMMENT ON COLUMN %s.%s IS %s',
                            $tableName,
                            $this->_driver->quoteIfAutoQuote($column),
                            $this->_driver->schemaValue($columnData['comment'])
                        );
                    }
                }

                $pk = $this->_getPrimaryKey($schema);
                if ($pk) {
                    $fieldName = $pk['columns'][0];
                    $out = Hash::merge($out, $this->getCreateAutoincrementSql($fieldName, $schema->name()));
                }

                return $out;
            }

            /**
            * {@inheritDoc}
            */
            public function truncateTableSql(TableSchema $schema): array
            {
                $name = $this->_driver->quoteIfAutoQuote($schema->name());
                $sequenceName = $this->_getSequenceName($schema->name());
                $result = [
                    sprintf('TRUNCATE TABLE %s', $name),
                    $this->dropSequenceIfExists($sequenceName),
                    $this->createSequenceIfNotExists($sequenceName),
                ];

                $keys = $schema->getPrimaryKey();
                if (count($keys) == 1 && $this->_driver->useAutoincrement()) {
                    $primaryKeyField = $schema->getColumn($keys[0]);
                    if ($this->__isInteger($primaryKeyField['type'])) {
                        $primaryKey = $this->_driver->quoteIfAutoQuote($keys[0]);
                        $result[] = sprintf(
                            'ALTER TABLE %s MODIFY(%s GENERATED AS IDENTITY (START WITH 1))',
                            $name,
                            $primaryKey
                        );
                    }
                }

                return $result;
            }

            /**
            * Generate the SQL to drop a table.
            *
            * @param \Cake\Database\Schema\TableSchema $table TableSchema instance
            * @return array SQL statements to drop a table.
            */
            public function dropTableSql(TableSchema $table): array
            {
                $sql = sprintf('DROP TABLE %s CASCADE CONSTRAINTS', $this->_driver->quoteIfAutoQuote($table->name()));

                return [$sql];
            }

            /**
            * Builds array with schema and table names.
            *
            * @param string $name Table name optionally with schema name.
            * @param array $config The connection configuration.
            * @return string
            */
            public function tableSplit($name, $config)
            {
                $name = strtoupper($name);
                $schema = null;
                $table = $name;
                if (strpos($name, '.') !== false) {
                    [$schema, $table] = explode('.', $table);
                } elseif (!empty($config['schema'])) {
                    $schema = strtoupper($config['schema']);
                }

                return [
                    $schema,
                    $table,
                ];
            }

            /**
            * Returns table primary key.
            *
            * @param \Cake\Database\Schema\TableSchema $table Table schema object.
            * @return array|null
            */
            protected function _getPrimaryKey(TableSchema $table)
            {
                $constraints = $table->constraints();
                foreach ($constraints as $name) {
                    $constraint = $table->getConstraint($name);
                    if ($this->_isSingleKey($table, [$constraint])) {
                        return $constraint;
                    }
                }

                return null;
            }

            /**
            * Checks if table primary key has single column.
            *
            * @param \Cake\Database\Schema\TableSchema $table Table schema object.
            * @param array $constraints Constraints list.
            * @return bool
            */
            protected function _isSingleKey(TableSchema $table, $constraints)
            {
                if (count($constraints) !== 1) {
                    return false;
                }
                $constraint = $constraints[0];
                $columns = $constraint['columns'];
                if ((is_countable($columns) ? count($columns) : 0) !== 1) {
                    return false;
                }
                $column = $table->getColumn($columns[0]);

                return $column['type'] === 'integer' && $constraint['type'] === TableSchema::CONSTRAINT_PRIMARY;
            }

            /**
            * Create sequence in database.
            *
            * @param string $sequenceName Sequence name.
            * @return string
            */
            public function getCreateSequenceSql($sequenceName)
            {
                return 'CREATE SEQUENCE ' . $sequenceName . ' START WITH 1' . ' MINVALUE 1' . ' INCREMENT BY 1' . ' CACHE 20';
            }

            /**
            * Remove sequence from database.
            *
            * @param string $sequenceName Sequence name.
            * @return string
            */
            public function getDropSequenceSql($sequenceName)
            {
                return 'DROP SEQUENCE ' . $sequenceName;
            }

            /**
            *
            *
            * @param string $name Sequence name.
            * @param string $createCommand Operation to execute.
            * @return string
            */
            public function createSequenceIfNotExists($name, $createCommand = null)
            {
                $name = strtoupper($name);
                if (empty($createCommand)) {
                    $createCommand = $this->getCreateSequenceSql($name);
                }

                return <<<SQL
                declare
                    ex NUMBER;
                begin
                    SELECT count(*) INTO ex FROM user_sequences WHERE sequence_name = '$name';
                    if (ex = 0) then
                        execute immediate '$createCommand';
                    end if;
                end;
        SQL;
            }

            /**
            *
            *
            * @param string $name Sequence name.
            * @param null $dropCommand Operation to execute.
            * @return string
            */
            public function dropSequenceIfExists($name, $dropCommand = null)
            {
                $name = strtoupper($name);
                if (empty($dropCommand)) {
                    $dropCommand = $this->getDropSequenceSql($name);
                }

                return <<<SQL
                declare
                    ex NUMBER;
                begin
                    SELECT count(*) INTO ex FROM user_sequences WHERE sequence_name = '$name';
                    if (ex = 1) then
                        execute immediate '$dropCommand';
                    end if;
                end;
        SQL;
            }

            /**
            * Generates trigger for autoincrement field. Used when apply schema for example when create table in text schema.
            *
            * @param string $name Primary key name.
            * @param string $tableName Table name.
            * @param int $start Start index for autoincrement field.
            * @return array
            */
            public function getCreateAutoincrementSql($name, $tableName, $start = 1)
            {
                if ($this->_driver->useAutoincrement()) {
                    return [];
                }
                $quotedTableName = $this->_driver->quoteIfAutoQuote($tableName);

                $quotedName = $this->_driver->quoteIfAutoQuote($name);

                $sql = [];

                $autoincrementIdentifierName = 't_' . $tableName;
                $sequenceName = $this->_getSequenceName($tableName);

                $sql[] = $this->createSequenceIfNotExists($sequenceName, $this->getCreateSequenceSQL($sequenceName));

                $sql[] = 'CREATE TRIGGER ' . $autoincrementIdentifierName . '
        BEFORE INSERT
        ON ' . $quotedTableName . '
        FOR EACH ROW
        DECLARE
        last_Sequence NUMBER;
        last_InsertID NUMBER;
        BEGIN
        SELECT ' . $sequenceName . '.NEXTVAL INTO :NEW.' . $quotedName . ' FROM DUAL;
        IF (:NEW.' . $quotedName . ' IS NULL OR :NEW.' . $quotedName . ' = 0) THEN
            SELECT ' . $sequenceName . '.NEXTVAL INTO :NEW.' . $quotedName . ' FROM DUAL;
        ELSE
            SELECT NVL(Last_Number, 0) INTO last_Sequence
                FROM User_Sequences
            WHERE Sequence_Name = \'' . strtoupper($sequenceName) . '\';
            SELECT :NEW.' . $quotedName . ' INTO last_InsertID FROM DUAL;
            WHILE (last_InsertID > last_Sequence) LOOP
                SELECT ' . $sequenceName . '.NEXTVAL INTO last_Sequence FROM DUAL;
            END LOOP;
        END IF;
        END;';

                return $sql;
            }

            /**
            * Generates sequence name based on convention that sequence names based on table name with prefix "SEQ_"
            *
            * @param string $name Original table name.
            * @return mixed
            */
            protected function _getSequenceName($name)
            {
                $name = 'seq_' . $name;

                return strtoupper($name);
            }

            /**
            * Transform string case on php side.
            *
            * @param string $value Binding value.
            * @return mixed
            */
            protected function _transformValueCase($value)
            {
                $case = $this->_driver->config('case');
                if ($case == 'lower') {
                    return strtolower($value);
                }

                return $value;
            }

            /**
            * Transform field case in sql response.
            *
            * @param string $field Field name.
            * @return string
            */
            protected function _transformFieldCase($field)
            {
                $case = $this->_driver->config('case');
                if ($case == 'lower') {
                    return "lower($field)";
                }

                return $field;
            }

            /**
            * Check for integer type.
            *
            * @param string $type Field type.
            *
            * @return bool
            */
            private function __isInteger(string $type): bool
            {
                $integerTypes = [
                    TableSchema::TYPE_INTEGER => true,
                    TableSchema::TYPE_SMALLINTEGER => true,
                    TableSchema::TYPE_TINYINTEGER => true,
                    TableSchema::TYPE_BIGINTEGER => true,
                ];

                return array_key_exists($type, $integerTypes);
            }
        }
