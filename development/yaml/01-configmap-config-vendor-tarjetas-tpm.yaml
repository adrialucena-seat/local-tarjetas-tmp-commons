kind: ConfigMap
apiVersion: v1
metadata:
  name: config-vendor-tarjetas-tpm
  namespace: tarjetas-tpm
data:
  TimestampBehavior.php: >
    <?php
    declare(strict_types=1);

    /**
    * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)
    * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    *
    * Licensed under The MIT License
    * For full copyright and license information, please see the LICENSE.txt
    * Redistributions of files must retain the above copyright notice.
    *
    * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    * @link          https://cakephp.org CakePHP(tm) Project
    * @since         3.0.0
    * @license       https://opensource.org/licenses/mit-license.php MIT License
    */
    namespace Cake\ORM\Behavior;

    use Cake\Database\Type\DateTimeType;
    use Cake\Database\TypeFactory;
    use Cake\Datasource\EntityInterface;
    use Cake\Event\EventInterface;
    use Cake\I18n\FrozenTime;
    use Cake\ORM\Behavior;
    use DateTimeInterface;
    use RuntimeException;
    use UnexpectedValueException;

    /**
    * Class TimestampBehavior
    */
    class TimestampBehavior extends Behavior
    {
        /**
        * Default config
        *
        * These are merged with user-provided config when the behavior is used.
        *
        * events - an event-name keyed array of which fields to update, and when, for a given event
        * possible values for when a field will be updated are "always", "new" or "existing", to set
        * the field value always, only when a new record or only when an existing record.
        *
        * refreshTimestamp - if true (the default) the timestamp used will be the current time when
        * the code is executed, to set to an explicit date time value - set refreshTimetamp to false
        * and call setTimestamp() on the behavior class before use.
        *
        * @var array<string, mixed>
        */
        protected $_defaultConfig = [
            'implementedFinders' => [],
            'implementedMethods' => [
                'timestamp' => 'timestamp',
                'touch' => 'touch',
            ],
            'events' => [
                'Model.beforeSave' => [
                    'CREATED' => 'new',
                    'MODIFIED' => 'always',
                ],
            ],
            'refreshTimestamp' => true,
        ];

        /**
        * Current timestamp
        *
        * @var \Cake\I18n\FrozenTime|null
        */
        protected $_ts;

        /**
        * Initialize hook
        *
        * If events are specified - do *not* merge them with existing events,
        * overwrite the events to listen on
        *
        * @param array<string, mixed> $config The config for this behavior.
        * @return void
        */
        public function initialize(array $config): void
        {
            if (isset($config['events'])) {
                $this->setConfig('events', $config['events'], false);
            }
        }

        /**
        * There is only one event handler, it can be configured to be called for any event
        *
        * @param \Cake\Event\EventInterface $event Event instance.
        * @param \Cake\Datasource\EntityInterface $entity Entity instance.
        * @throws \UnexpectedValueException if a field's when value is misdefined
        * @return true Returns true irrespective of the behavior logic, the save will not be prevented.
        * @throws \UnexpectedValueException When the value for an event is not 'always', 'new' or 'existing'
        */
        public function handleEvent(EventInterface $event, EntityInterface $entity): bool
        {
            $eventName = $event->getName();
            $events = $this->_config['events'];

            $new = $entity->isNew() !== false;
            $refresh = $this->_config['refreshTimestamp'];

            foreach ($events[$eventName] as $field => $when) {
                if (!in_array($when, ['always', 'new', 'existing'], true)) {
                    throw new UnexpectedValueException(sprintf(
                        'When should be one of "always", "new" or "existing". The passed value "%s" is invalid',
                        $when
                    ));
                }
                if (
                    $when === 'always' ||
                    (
                        $when === 'new' &&
                        $new
                    ) ||
                    (
                        $when === 'existing' &&
                        !$new
                    )
                ) {
                    $this->_updateField($entity, $field, $refresh);
                }
            }

            return true;
        }

        /**
        * implementedEvents
        *
        * The implemented events of this behavior depend on configuration
        *
        * @return array<string, mixed>
        */
        public function implementedEvents(): array
        {
            return array_fill_keys(array_keys($this->_config['events']), 'handleEvent');
        }

        /**
        * Get or set the timestamp to be used
        *
        * Set the timestamp to the given DateTime object, or if not passed a new DateTime object
        * If an explicit date time is passed, the config option `refreshTimestamp` is
        * automatically set to false.
        *
        * @param \DateTimeInterface|null $ts Timestamp
        * @param bool $refreshTimestamp If true timestamp is refreshed.
        * @return \Cake\I18n\FrozenTime
        */
        public function timestamp(?DateTimeInterface $ts = null, bool $refreshTimestamp = false): DateTimeInterface
        {
            if ($ts) {
                if ($this->_config['refreshTimestamp']) {
                    $this->_config['refreshTimestamp'] = false;
                }
                $this->_ts = new FrozenTime($ts);
            } elseif ($this->_ts === null || $refreshTimestamp) {
                $this->_ts = new FrozenTime();
            }

            return $this->_ts;
        }

        /**
        * Touch an entity
        *
        * Bumps timestamp fields for an entity. For any fields configured to be updated
        * "always" or "existing", update the timestamp value. This method will overwrite
        * any pre-existing value.
        *
        * @param \Cake\Datasource\EntityInterface $entity Entity instance.
        * @param string $eventName Event name.
        * @return bool true if a field is updated, false if no action performed
        */
        public function touch(EntityInterface $entity, string $eventName = 'Model.beforeSave'): bool
        {
            $events = $this->_config['events'];
            if (empty($events[$eventName])) {
                return false;
            }

            $return = false;
            $refresh = $this->_config['refreshTimestamp'];

            foreach ($events[$eventName] as $field => $when) {
                if (in_array($when, ['always', 'existing'], true)) {
                    $return = true;
                    $entity->setDirty($field, false);
                    $this->_updateField($entity, $field, $refresh);
                }
            }

            return $return;
        }

        /**
        * Update a field, if it hasn't been updated already
        *
        * @param \Cake\Datasource\EntityInterface $entity Entity instance.
        * @param string $field Field name
        * @param bool $refreshTimestamp Whether to refresh timestamp.
        * @return void
        */
        protected function _updateField(EntityInterface $entity, string $field, bool $refreshTimestamp): void
        {
            if ($entity->isDirty($field)) {
                return;
            }

            $ts = $this->timestamp(null, $refreshTimestamp);

            $columnType = $this->table()->getSchema()->getColumnType($field);
            if (!$columnType) {
                return;
            }

            /** @var \Cake\Database\Type\DateTimeType $type */
            $type = TypeFactory::build($columnType);

            if (!$type instanceof DateTimeType) {
                throw new RuntimeException('TimestampBehavior only supports columns of type DateTimeType.');
            }

            $class = $type->getDateTimeClassName();

            $entity->set($field, new $class($ts));
        }
    }
  OCI8Statement.php: >
    <?php
    declare(strict_types=1);

    /**
    * Copyright 2015 - 2020, Cake Development Corporation (http://cakedc.com)
    *
    * Licensed under The MIT License
    * Redistributions of files must retain the above copyright notice.
    *
    * @copyright Copyright 2015 - 2020, Cake Development Corporation (http://cakedc.com)
    * @license MIT License (http://www.opensource.org/licenses/mit-license.php)
    */
    namespace CakeDC\OracleDriver\Database\OCI8;

    use PDO;

    /**
    * The OCI8 implementation of the Statement interface.
    */
    class OCI8Statement extends \PDOStatement implements \IteratorAggregate
    {
        /**
        * @var bool
        */

        protected $_returnLobs = true;

        /**
        * @var resource
        */
        protected $_dbh;

        /**
        * @var resource
        */
        protected $_sth;

        /**
        * @var \CakeDC\OracleDriver\Database\OCI8\OCI8Connection
        */
        protected $_conn;

        /**
        * @var string
        */
        protected static $_PARAM = ':param';

        /**
        * @var array
        */
        protected static $fetchModeMap = [
            PDO::FETCH_BOTH => OCI_BOTH,
            PDO::FETCH_ASSOC => OCI_ASSOC,
            PDO::FETCH_NUM => OCI_NUM,
            PDO::FETCH_COLUMN => OCI_NUM,
        ];

        /**
        * Column number for PDO::FETCH_COLUMN fetch mode
        *
        * @var int
        */
        protected $_fetchColumnNumber = 0;

        /**
        * @var int
        */
        protected $_defaultFetchMode = PDO::ATTR_DEFAULT_FETCH_MODE;

        /**
        * @var array
        */
        protected $_paramMap = [];

        /**
        * @var array
        */
        protected $_values = [];

        protected $_fetchMode = PDO::ATTR_DEFAULT_FETCH_MODE;

        protected $_fetchClassName = '\stdClass';

        protected $_fetchIntoObject = null;

        protected $_fetchArguments = [];

        protected $_results = [];

        /**
        * Creates a new OCI8Statement that uses the given connection handle and SQL statement.
        *
        * @param resource $dbh The connection handle.
        * @param string|resource $statement The SQL statement.
        * @param \CakeDC\OracleDriver\Database\OCI8\OCI8Connection $conn OCI connection.
        */
        public function __construct($dbh, $statement, OCI8Connection $conn)
        {
            if (is_resource($statement)) {
                $this->_sth = $statement;
                $paramMap = [];
            } else {
                [$statement, $paramMap] = self::convertPositionalToNamedPlaceholders($statement);
                $this->_sth = oci_parse($dbh, $statement);
            }
            $this->_dbh = $dbh;
            $this->_paramMap = $paramMap;
            $this->_conn = $conn;
        }

        /**
        * Converts positional (?) into named placeholders (:param<num>).
        *
        * Oracle does not support positional parameters, hence this method converts all
        * positional parameters into artificially named parameters. Note that this conversion
        * is not perfect. All question marks (?) in the original statement are treated as
        * placeholders and converted to a named parameter.
        *
        * The algorithm uses a state machine with two possible states: InLiteral and NotInLiteral.
        * Question marks inside literal strings are therefore handled correctly by this method.
        * This comes at a cost, the whole sql statement has to be looped over.
        *
        * @param string $statement The SQL statement to convert.
        *
        * @return string
        */
        public static function convertPositionalToNamedPlaceholders($statement)
        {
            $count = 1;
            $inLiteral = false;
            $stmtLen = strlen($statement);
            $paramMap = [];
            for ($i = 0; $i < $stmtLen; $i++) {
                if ($statement[$i] === '?' && !$inLiteral) {
                    $paramMap[$count] = ":param$count";
                    $len = strlen($paramMap[$count]);
                    $statement = substr_replace($statement, ":param$count", $i, 1);
                    $i += $len - 1;
                    $stmtLen = strlen($statement);
                    ++$count;
                } elseif ($statement[$i] === "'" || $statement[$i] === '"') {
                    $inLiteral = !$inLiteral;
                }
            }

            return [$statement, $paramMap];
        }

        /**
        * {@inheritdoc}
        */
        public function bindValue($param, $value, $type = null)
        {
            $this->_values[$param] = $value;

            return $this->bindParam($param, $this->_values[$param], $type, null);
        }

        /**
        * {@inheritdoc}
        */
        public function bindParam($column, &$variable, $type = null, $length = null, $driverData = null)
        {
            $column = $this->_paramMap[$column] ?? $column;

            // @todo add additional type passing: as an option we could accept $type as array
            // where $type = ['ociType' => "REAL_OCI_TYPE", 'plsql_type' => 'VARRAY', 'php_type' => 'string']
            // this way we could choose correct type and correct binding function like oci_bind_array_by_name

            if ($type == \PDO::PARAM_STMT) {
                $variable = oci_new_cursor($this->_dbh);

                return oci_bind_by_name($this->_sth, $column, $variable, -1, OCI_B_CURSOR);
            } elseif ($type == \PDO::PARAM_LOB) {
                $lob = oci_new_descriptor($this->_dbh, OCI_D_LOB);
                $lob->writeTemporary($variable, OCI_TEMP_BLOB);

                return oci_bind_by_name($this->_sth, $column, $lob, -1, OCI_B_BLOB);
            } elseif ($length !== null) {
                return oci_bind_by_name($this->_sth, $column, $variable, $length);
            }

            return oci_bind_by_name($this->_sth, $column, $variable);
        }

        /**
        * {@inheritdoc}
        */
        public function closeCursor()
        {
            return true;
        }

        /**
        * {@inheritdoc}
        */
        public function __destruct()
        {
            if (is_resource($this->_sth)) {
                oci_free_statement($this->_sth);
            }
        }

        /**
        * {@inheritdoc}
        */
        public function columnCount()
        {
            return oci_num_fields($this->_sth);
        }

        /**
        * {@inheritdoc}
        */
        public function errorCode()
        {
            $error = oci_error($this->_sth);
            if ($error !== false) {
                $error = $error['code'];
            } else {
                return '00000';
            }

            return $error;
        }

        /**
        * {@inheritdoc}
        */
        public function errorInfo()
        {
            return oci_error($this->_sth);
        }

        /**
        * {@inheritdoc}
        */
        public function execute($params = null)
        {
            if ($params) {
                $hasZeroIndex = array_key_exists(0, $params);
                foreach ($params as $key => $val) {
                    if ($hasZeroIndex && is_numeric($key)) {
                        $this->bindValue($key + 1, $val);
                    } else {
                        $this->bindValue($key, $val);
                    }
                }
            }

            $ret = @oci_execute($this->_sth, $this->_conn->getExecuteMode());
            if (!$ret) {
                throw OCI8Exception::fromErrorInfo($this->errorInfo());
            }

            return $ret;
        }

        /**
        * {@inheritdoc}
        */
        public function getIterator()
        {
            $data = $this->fetchAll();

            return new \ArrayIterator($data);
        }

        /**
        * {@inheritdoc}
        */
        public function fetch($fetchMode = null, $orientation = null, $offset = null)
        {
            $toLowercase = ($this->getAttribute(PDO::ATTR_CASE) == PDO::CASE_LOWER);
            $nullToString = ($this->getAttribute(PDO::ATTR_ORACLE_NULLS) == PDO::NULL_TO_STRING);
            $nullEmptyString = ($this->getAttribute(PDO::ATTR_ORACLE_NULLS) == PDO::NULL_EMPTY_STRING);

            $fetchMode = $fetchMode ?: $this->_defaultFetchMode;

            switch ($fetchMode) {
                case PDO::FETCH_BOTH:
                    $rs = oci_fetch_array($this->_sth);
                    if ($rs === false) {
                        return false;
                    }
                    if ($toLowercase) {
                        $rs = array_change_key_case($rs);
                    } 
                    if ($this->_returnLobs && is_array($rs)) {
                        foreach ($rs as $field => $value) {
                            if (is_object($value)) {
                                $rs[$field] = $value->load();
                            }
                        }
                    }

                    return $rs;

                case PDO::FETCH_ASSOC:
                    $rs = oci_fetch_assoc($this->_sth);
                    if ($rs === false) {
                        return false;
                    }

                    $rs = $this->pseudoCamelCase($rs);

                    if ($toLowercase) {
                        $rs = array_change_key_case($rs);
                    }
                    if ($this->_returnLobs && is_array($rs)) {
                        foreach ($rs as $field => $value) {
                            if (is_object($value)) {
                                $rs[$field] = $value->load();
                            }
                        }
                    }

                    return $rs;

                case PDO::FETCH_NUM:
                    $rs = oci_fetch_row($this->_sth);
                    if ($rs === false) {
                        return false;
                    }
                    if ($this->_returnLobs && is_array($rs)) {
                        foreach ($rs as $field => $value) {
                            if (is_object($value)) {
                                $rs[$field] = $value->load();
                            }
                        }
                    }

                    return $rs;

                case PDO::FETCH_COLUMN:
                    $rs = oci_fetch_row($this->_sth);
                    $columnNumber = (int)$this->_fetchColumnNumber;
                    if (is_array($rs) && array_key_exists($columnNumber, $rs)) {
                        $value = $rs[$columnNumber];
                        if (is_object($value)) {
                            return $value->load();
                        } else {
                            return $value;
                        }
                    } else {
                        return false;
                    }
                    break;

                case PDO::FETCH_OBJ:
                case PDO::FETCH_INTO:
                case PDO::FETCH_CLASS:
                case PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE:
                    $rs = oci_fetch_assoc($this->_sth);
                    if ($rs === false) {
                        return false;
                    }
                    if ($toLowercase) {
                        $rs = array_change_key_case($rs);
                    }

                    if ($fetchMode === PDO::FETCH_INTO) {
                        if (is_object($this->_fetchIntoObject)) {
                            $object = $this->_fetchIntoObject;
                        } else {
                            return false;
                        }
                    } else {
                        if ($fetchMode === PDO::FETCH_OBJ) {
                            $className = '\stdClass';
                            $arguments = [];
                        } else {
                            $className = $this->_fetchClassName;
                            $arguments = $this->_fetchArguments;
                        }

                        if ($arguments) {
                            $reflectionClass = new \ReflectionClass($className);
                            $object = $reflectionClass->newInstanceArgs($arguments);
                        } else {
                            $object = new $className();
                        }
                    }

                    foreach ($rs as $field => $value) {
                        if (is_null($value) && $nullToString) {
                            $rs[$field] = '';
                        }

                        if (empty($rs[$field]) && $nullEmptyString) {
                            $rs[$field] = null;
                        }

                        $object->$field = $this->_returnLobs && is_object($value) ? $value->load() : $value;
                    }

                    return $object;
            }

            return false;
        }

        public function pseudoCamelCase($rs){
            $rsCamelCase = [];
            if (is_array($rs)) {
                foreach ($rs as $key => $value) {
                    if($key == 'COUNT' || $key == 'EXISTING'){
                        $key = strtolower($key);
                    }else{
                        $pos = (strpos($key,'_CREATED'))? 7:8;
                        if(strpos($key,'_CREATED') || strpos($key,'_MODIFIED')){
                            $key = strtoupper(substr($key,0,1)) . strtolower(substr($key,1,(strlen($key)-$pos-1))) . substr($key,(strlen($key)-$pos));
                        }else if(strpos($key,'CJOIN')){
                            $key = strtoupper(substr($key,0,1)) . strtolower(substr($key,1,strpos($key,'CJOIN')-1)) . str_replace("CJOIN",'CJoin',substr($key,strpos($key,'CJOIN')));
                        }else{
                            $key = strtoupper(substr($key,0,1)) . strtolower(substr($key,1));
                            if(strpos($key,'__')){
                                $key2 = strtoupper(substr($key,0,1)) . strtolower(substr($key,1,strpos($key,'__')-1)) . strtoupper(substr($key,strpos($key,'__')));
                                // echo('<br>' . $key2 . '<br>');
                                $rsCamelCase[$key2] = $value;
                            }
                        }
                    }
                    
                    
                    $rsCamelCase[$key] = $value;
                } 
                
                // echo('<br>');
                // print_r($rsCamelCase);
                // echo('<br>');
            }
            return $rsCamelCase;
        }

        /**
        * {@inheritdoc}
        */
        public function fetchAll($fetchMode = null, $className = null, $arguments = null)
        {
            $fetchArgument = $className;
            $this->setFetchMode($fetchMode, $fetchArgument, $arguments);

            $this->_results = [];
            while ($row = $this->fetch()) {
                if (is_resource(reset($row))) {
                    $stmt = new OCI8Statement($this->_dbh, reset($row), $this->_conn);
                    $stmt->execute();
                    $stmt->setFetchMode($fetchMode, $fetchArgument, $arguments);
                    while ($rs = $stmt->fetch()) {
                        $this->_results[] = $rs;
                    }
                } else {
                    $this->_results[] = $row;
                }
            }

            return $this->_results;
        }

        /**
        * {@inheritdoc}
        */
        public function fetchColumn($columnIndex = 0)
        {
            $row = oci_fetch_array($this->_sth, OCI_NUM | OCI_RETURN_NULLS | OCI_RETURN_LOBS);

            if ($row === false) {
                return false;
            }

            return $row[$columnIndex] ?? null;
        }

        /**
        * {@inheritdoc}
        */
        public function rowCount()
        {
            if (is_resource($this->_sth)) {
                return oci_num_rows($this->_sth);
            }

            return 0;
        }

        /**
        * Retrieve a statement attribute
        *
        * @param string $attribute Attribute id.
        * @return mixed The attribute value.
        */
        public function getAttribute($attribute)
        {
            return $this->_conn->getConfig((string)$attribute);
        }

        /**
        * Set the default fetch mode for this statement
        *
        * @param int|null $fetchMode The fetch mode must be one of the PDO::FETCH_* constants.
        * @param mixed|null $param Column number, class name or object.
        * @param array|null $arguments Constructor arguments.
        * @throws \CakeDC\OracleDriver\Database\OCI8\Oci8Exception
        * @return bool TRUE on success or FALSE on failure.
        */
        public function setFetchMode($fetchMode, $param = null, $arguments = [])
        {
            $this->_defaultFetchMode = $fetchMode;

            switch ($fetchMode) {
                case PDO::FETCH_ASSOC:
                case PDO::FETCH_NUM:
                case PDO::FETCH_BOTH:
                case PDO::FETCH_OBJ:
                    $this->_fetchMode = $fetchMode;
                    $this->_fetchColumnNumber = 0;
                    $this->_fetchClassName = '\stdClass';
                    $this->_fetchArguments = [];
                    $this->_fetchIntoObject = null;
                    break;
                case PDO::FETCH_CLASS:
                case PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE:
                    $this->_fetchMode = $fetchMode;
                    $this->_fetchColumnNumber = 0;
                    $this->_fetchClassName = '\stdClass';
                    if ($param) {
                        $this->_fetchClassName = $param;
                    }
                    $this->_fetchArguments = $arguments;
                    $this->_fetchIntoObject = null;
                    break;
                case PDO::FETCH_INTO:
                    if (!is_object($param)) {
                        throw new OCI8Exception(__('$param must be instance of an object'));
                    }
                    $this->_fetchMode = $fetchMode;
                    $this->_fetchColumnNumber = 0;
                    $this->_fetchClassName = '\stdClass';
                    $this->_fetchArguments = [];
                    $this->_fetchIntoObject = $param;
                    break;
                case PDO::FETCH_COLUMN:
                    $this->_fetchMode = $fetchMode;
                    $this->_fetchColumnNumber = (int)$param;
                    $this->_fetchClassName = '\stdClass';
                    $this->_fetchArguments = [];
                    $this->_fetchIntoObject = null;
                    break;
                default:
                    throw new OCI8Exception(__('Requested fetch mode is not supported by this implementation'));
            }

            return true;
        }
    }
  PasswordIdentifier.php: >
    <?php
    declare(strict_types=1);

    /**
    * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)
    * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    *
    * Licensed under The MIT License
    * For full copyright and license information, please see the LICENSE.txt
    * Redistributions of files must retain the above copyright notice.
    *
    * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    * @link          https://cakephp.org CakePHP(tm) Project
    * @since         1.0.0
    * @license       https://opensource.org/licenses/mit-license.php MIT License
    */
    namespace Authentication\Identifier;

    use Authentication\Identifier\Resolver\ResolverAwareTrait;
    use Authentication\Identifier\Resolver\ResolverInterface;
    use Authentication\PasswordHasher\PasswordHasherFactory;
    use Authentication\PasswordHasher\PasswordHasherInterface;
    use Authentication\PasswordHasher\PasswordHasherTrait;

    /**
    * Password Identifier
    *
    * Identifies authentication credentials with password
    *
    * ```
    *  new PasswordIdentifier([
    *      'fields' => [
    *          'username' => ['username', 'email'],
    *          'password' => 'password'
    *      ]
    *  ]);
    * ```
    *
    * When configuring PasswordIdentifier you can pass in config to which fields,
    * model and additional conditions are used.
    */
    class PasswordIdentifier extends AbstractIdentifier
    {
        use PasswordHasherTrait {
            getPasswordHasher as protected _getPasswordHasher;
        }
        use ResolverAwareTrait;

        /**
        * Default configuration.
        * - `fields` The fields to use to identify a user by:
        *   - `username`: one or many username fields.
        *   - `password`: password field.
        * - `resolver` The resolver implementation to use.
        * - `passwordHasher` Password hasher class. Can be a string specifying class name
        *    or an array containing `className` key, any other keys will be passed as
        *    config to the class. Defaults to 'Default'.
        *
        * @var array
        */
        protected $_defaultConfig = [
            'fields' => [
                self::CREDENTIAL_USERNAME => 'username',
                self::CREDENTIAL_PASSWORD => 'password',
            ],
            'resolver' => 'Authentication.Orm',
            'passwordHasher' => null,
        ];

        /**
        * Return password hasher object.
        *
        * @return \Authentication\PasswordHasher\PasswordHasherInterface Password hasher instance.
        */
        public function getPasswordHasher(): PasswordHasherInterface
        {
            if ($this->_passwordHasher === null) {
                $passwordHasher = $this->getConfig('passwordHasher');
                if ($passwordHasher !== null) {
                    $passwordHasher = PasswordHasherFactory::build($passwordHasher);
                } else {
                    $passwordHasher = $this->_getPasswordHasher();
                }
                $this->_passwordHasher = $passwordHasher;
            }

            return $this->_passwordHasher;
        }

        /**
        * @inheritDoc
        */
        public function identify(array $credentials)
        {
            if (!isset($credentials[self::CREDENTIAL_USERNAME])) {
                return null;
            }

            $identity = $this->_findIdentity($credentials[self::CREDENTIAL_USERNAME]);
            if (array_key_exists(self::CREDENTIAL_PASSWORD, $credentials)) {
                $password = $credentials[self::CREDENTIAL_PASSWORD];
                if (!$this->_checkPassword($identity, $password)) {
                    return null;
                }
            }

            return $identity;
        }

        /**
        * Find a user record using the username and password provided.
        * Input passwords will be hashed even when a user doesn't exist. This
        * helps mitigate timing attacks that are attempting to find valid usernames.
        *
        * @param array|\ArrayAccess|null $identity The identity or null.
        * @param string|null $password The password.
        * @return bool
        */
        protected function _checkPassword($identity, ?string $password): bool
        {
            $passwordField = $this->getConfig('fields.' . self::CREDENTIAL_PASSWORD);

            if ($identity === null) {
                $identity = [
                    $passwordField => '',
                ];
            }

            $hasher = $this->getPasswordHasher();
            $hashedPassword = $identity[strtoupper($passwordField)];
            if (
                $hashedPassword === null ||
                !$hasher->check((string)$password, $hashedPassword)
            ) {
                return false;
            }

            $this->_needsPasswordRehash = $hasher->needsRehash($hashedPassword);

            return true;
        }

        /**
        * Find a user record using the username/identifier provided.
        *
        * @param string $identifier The username/identifier.
        * @return \ArrayAccess|array|null
        */
        protected function _findIdentity(string $identifier)
        {
            $fields = $this->getConfig('fields.' . self::CREDENTIAL_USERNAME);
            $conditions = [];
            foreach ((array)$fields as $field) {
                $conditions[$field] = $identifier;
            }

            return $this->getResolver()->find($conditions, ResolverInterface::TYPE_OR);
        }
    }
    